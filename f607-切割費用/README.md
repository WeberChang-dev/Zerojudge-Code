    這題真的太有趣，每次學了新觀念都能回來解這題
    <解法一>
    一開始剛學STL用set解，用一點反向思考
    先存一個以切割順序為index，切割位置為value的陣列
    然後從最後切割的開始跑迴圈
    用.find()找到該點位置後用*next-*prev得到該段費用
    再pop該點
    <解法二>
    之後學了二分搜，突然發現這題也適用
    但就用vector當容器，且是用正面思考
    一樣先存一個以切割順序為index，切割位置為value的陣列
    從第一個切割的點開始跑迴圈
    先搜到第一個大於欲切割點的位置
    再用第一個大於-第一個小於
    最後insert該切割點於第一個大於的前面
    速度比我預期的快 AC (66ms, 2.9MB)
    <解法三>
    這個做法只是把解法二的vector改成最近學的linked list
    本來以為可以省略insert用移動節點來加速
    結果比解法二慢 	AC (71ms, 3.4MB)
    或許是因為二分搜的
    解法二vector長度由短到長，進而使二分搜變快
    解法三長度一直是n
    解法三應該還能優化，有變快會再更新
